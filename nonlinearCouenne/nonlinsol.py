#!/usr/bin/env python3

#nonlinsol pyomo

#
# unlike ReplaceFormula.py which creates an AML model, this just uses pyomo to solve
#

### this is going to
### 1. take the text input file,
### 1.1. import pyomo environ
### 1.2. model the s,t,p variables,and make concrete model
### 1.3. define the objective function based on input file, (python function)
### 2. create a nonlinear objective function and write to objex.py
### 3. pass resulting output formatted file to coenne solver as rule
#
#
# https://pyomo.readthedocs.io/en/stable/developer_reference/expressions/performance.html



#
#---------------------------------------
#

#import objective expression
# from objex import nonlinear_objective_expression
#

from pyomo.environ import *

import re
import sys
import os
import time

#
#---------------------------------------
#



#
#---------------------------------------
#

def parse_input_data_after_read(_ifo_read):
    """FUNCTION ARG SHOULD BE STRING READ FROM FILE, NOT FILENAME"""
    """ parses input and formats it for Coenne compatability"""
    """ RETURN STRING"""
    data = _ifo_read
    data = data.replace("Sin", "sin")
    data = data.replace("Cos", "cos")
    data = data.replace("[", "(")
    data = data.replace("]", ")")
    data = data.replace("{", "(")
    data = data.replace("}", ")")
    data = data.replace("(s","(m.s")
    data = data.replace("t","m.t")
    data = re.sub(r'([0-9\)]) ([a-zA-Z\(])', r'\1*\2', data)
    data = re.sub(r'([\+\-])', r' \1 ', data)
    data = data.replace("*s", "*m.s")
    data +=";"

    #trim off the leading term and insert multiplication sign
    reg1 = '\(.*?\)'
    coef = re.findall(reg1,data)[0]
    l = len(coef)
    data = coef + '*' + data[l:]
    

    return data;
    #ofo.write(data+";")
    
    
#
#-------------------------------------------------------------------
#

def prepend_to_file(_outputFile):
    """FUNCTION ARG SHOULD BE STRING """
    """this couenne formatting code is copied from previous source, might contain issues """
    """RETURNS A FILE OBJECT THAT SHOULD BE CLOSED """
    ofo = open(_outputFile, "w")
    ofo.write("from pyomo.environ import *\n")
    ofo.write("def nonlinear_objective_function_expression(m):\n")

    # returns an open file #
    return ofo

#-----
# MAIN ---------------------------------------------------------------
#-----

def main():
    #
    # NAME OF OUTPUT FILES PRODUCED BY THIS PROGRAM
    #
    
    OBJECTIVE_EXPRESSION_RULE_FILE_NAME = "objex.py";
    #COUENNE_SOLVER_OUTPUT_FILE_NAME = "couenne_solved";
    
    #
    # - - - - - - - - - - - - - - - - - - - - -
    #
    
    """ ARGUMENT HANDLING """
    try:
        ifo = open(sys.argv[1],'r')
    except IndexError:
        print('<!> FIRST input argument should be a FILE')
        print('<x> exiting')
        sys.exit()
    else:
 ############################################## argv is 'objex.py': INVOKE PYOMO and EXIT
        if sys.argv[1] == 'objex.py':
            os.system("clear")
            from objex import nonlinear_objective_function_expression

            model = ConcreteModel()
            ### CHANGE 3 to PI ###

            model.s = Var(within=NonNegativeReals,
                          bounds=(0,3),
                          doc='Nonnegative')
            model.t = Var(within=NonNegativeReals,
                          bounds=(0,3),
                          doc='Nonnegative')
            model.obj = Objective(rule=nonlinear_objective_function_expression,
                                  sense = minimize)
            #
            # CONSTRAINTS go here
            #
            # model.c1
            # model.c2
            #

            solver=SolverFactory("couenne")
            results=solver.solve(model,tee=True)
            model.display()

            sys.exit()
 ##################################################################### EXIT ###########

            #
            # otherwise clear term and
            # announce that objex.py is being dynamically generated and should 
            # be loaded as argument upon next run of program. In future this can be 
            # done programmatically via code generation and adding to sys.modules
            #
            
        os.system("clear")
        print("CREATING objex.py FROM {} FILE GENERATED BY MATHEMATICA\n".format(str(sys.argv[1])))
    #
    # CREATE OBJEX MODULE --------------------------------------------------------------
    #

    """ prompts input for p, must be specific to QAOA program supplied """
    spacer = ". . . . . . . . . . . . . . . . . ."
    message = "<> Enter the corresponding `p` for QAOA \n\n\n{}{}\n\n\n<> `p`= ".format(spacer,str(sys.argv[1]))
    
    while(True):
        try:
            p_integer=int(input(message))
        except ValueError:
            print("<> `p` must be an integer.")
            continue
        else:
            if p_integer>10:
                print("<!> you have entered a `p` value that is greater than 10")
            print("<> `p` set to {}".format(str(p_integer)))
            break
                
    #
    #--------------------------------------------------------------------
    #
    
    p_string = str(p_integer)
    f_name_arg = str(sys.argv[1]).split('.')
    timestr = time.strftime("%H%M%S_%Y-%m-%d")

    #
    # unused for now ^^^
    #
    
    f_name_ext = str(OBJECTIVE_EXPRESSION_RULE_FILE_NAME)
    ofo = prepend_to_file(f_name_ext) # PREPENDS FILE FOR COUENNE
    #  returns OPEN FILE OBJECT that should be closed

    #
    #------------------------------------------------------------------
    #

    read_from_input_file = ifo.read() # RAW INPUT STRING SUPPLIED BY USER
    data = parse_input_data_after_read(read_from_input_file) # PROCESS for PYOMO
    ofo.write("    return "+data)

    #
    #------------------------------------------------------------------
    #

    # # # # # # # # # # # # # # # # # # # OLD CODE; SAVED FOR POSTERITY
    #data = data.replace("Sin", "sin")
    #data = data.replace("Cos", "cos")
    #data = data.replace("[", "(")
    #data = data.replace("]", ")")
    #data = data.replace("{", "(")
    #data = data.replace("}", ")")
    #data = re.sub(r'([0-9\)]) ([a-zA-Z\(])', r'\1*\2', data)
    #data = re.sub(r'([\+\-])', r' \1 ', data)
    #ofo.write(data+";")
    # # # # # # # # # # # # # # # # # # #

    #
    #-----------------------------------------------------------------------------
    #
    
    ifo.close() # CLOSE INPUT FILE OBJECT
    ofo.close() # CLOSE OUTPUT FILE OBJECT
    

    #
    #-------------------------------------------------------------------------
    #
    print("objex.py created at {} from {}\n".format(timestr,f_name_arg))
    os.system("cat {}".format(f_name_ext))
    print("... run this program with 'objex.py' as argument to invoke solver (will make cli option l8r)")

if __name__ == "__main__":
    #
    print("<> ARGUMENT COUNT".format(sys.argv))
    #
    for i, arg in enumerate(sys.argv):
        print("<{}>  {}".format(i,arg))
    #
    main()
